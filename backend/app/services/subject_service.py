# backend/app/services/subject_service.py

from datetime import datetime
from bson import ObjectId
from typing import Optional, List, Dict

from app.core.database import db
from app.core.models.subject import Subject


class SubjectService:
    """
    Subject service layer.
    
    Subject is the root container for:
    - Syllabus
    - Study Plan
    - Study Sessions
    - Progress Tracking
    
    Workflow:
    1. Create empty subject
    2. Upload syllabus (linked via SyllabusService)
    3. Generate plan (via PlannerService)
    4. Start studying (via StudySessionService)
    """

    # ============================
    # CREATE SUBJECT
    # ============================

    @staticmethod
    async def create_subject(
        *,
        user_id: ObjectId,
        subject_name: str,
    ) -> Subject:
        """
        Step 1: Create empty subject.
        Syllabus can be uploaded later.
        
        Args:
            user_id: Owner
            subject_name: Display name (e.g., "Biology")
            
        Returns:
            Subject with status="created"
            
        Raises:
            ValueError: If subject name already exists for user
        """
        subjects_col = db.subjects()
        
        # Validate unique subject name per user
        existing = await subjects_col.find_one({
            "user_id": user_id,
            "subject_name": subject_name
        })
        
        if existing:
            raise ValueError(
                f"Subject '{subject_name}' already exists. "
                "Choose a different name."
            )
        
        # Create subject
        subject_doc = {
            "user_id": user_id,
            "subject_name": subject_name,
            "syllabus_id": None,  # Empty until upload
            "plan": None,         # Empty until Planner runs
            "status": "created",  # Lifecycle tracking
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
        }
        
        result = await subjects_col.insert_one(subject_doc)
        subject_doc["_id"] = result.inserted_id
        
        return Subject(**subject_doc)

    # ============================
    # LINK SYLLABUS (Internal)
    # ============================

    @staticmethod
    async def link_syllabus(
        *,
        user_id: ObjectId,
        subject_id: ObjectId,
        syllabus_id: ObjectId,
    ) -> Subject:
        """
        Step 2: Link syllabus after upload.
        Called internally by SyllabusService.
        
        Updates:
        - subject.syllabus_id = syllabus_id
        - subject.status = "syllabus_uploaded"
        """
        subjects_col = db.subjects()
        
        result = await subjects_col.update_one(
            {
                "_id": subject_id,
                "user_id": user_id
            },
            {
                "$set": {
                    "syllabus_id": syllabus_id,
                    "status": "syllabus_uploaded",
                    "updated_at": datetime.utcnow()
                }
            }
        )
        
        if result.matched_count == 0:
            raise ValueError("Subject not found or unauthorized")
        
        updated = await subjects_col.find_one({"_id": subject_id})
        return Subject(**updated)

    # ============================
    # UPDATE PLAN (Called by PlannerService)
    # ============================

    @staticmethod
    async def update_plan(
        *,
        user_id: ObjectId,
        subject_id: ObjectId,
        plan: Dict,
    ) -> Subject:
        """
        Step 3: Store plan generated by Planner Agent.
        Called by PlannerService.
        
        Updates:
        - subject.plan = {...}
        - subject.status = "planned"
        """
        subjects_col = db.subjects()
        
        result = await subjects_col.update_one(
            {
                "_id": subject_id,
                "user_id": user_id
            },
            {
                "$set": {
                    "plan": plan,
                    "status": "planned",
                    "updated_at": datetime.utcnow()
                }
            }
        )
        
        if result.matched_count == 0:
            raise ValueError("Subject not found or unauthorized")
        
        updated = await subjects_col.find_one({"_id": subject_id})
        return Subject(**updated)

    # ============================
    # MARK AS IN PROGRESS
    # ============================

    @staticmethod
    async def mark_in_progress(
        *,
        user_id: ObjectId,
        subject_id: ObjectId,
    ) -> Subject:
        """
        Step 4: Mark subject as in_progress when first session starts.
        Called by StudySessionService.
        """
        subjects_col = db.subjects()
        
        result = await subjects_col.update_one(
            {
                "_id": subject_id,
                "user_id": user_id,
                "status": "planned"  # Only transition from planned
            },
            {
                "$set": {
                    "status": "in_progress",
                    "updated_at": datetime.utcnow()
                }
            }
        )
        
        if result.matched_count == 0:
            # Already in_progress or invalid state
            pass
        
        updated = await subjects_col.find_one({"_id": subject_id})
        return Subject(**updated)

    # ============================
    # GET SUBJECT
    # ============================

    @staticmethod
    async def get_subject_by_id(
        *,
        user_id: ObjectId,
        subject_id: ObjectId,
    ) -> Optional[Subject]:
        """
        Retrieve subject by ID (ownership enforced).
        """
        subjects_col = db.subjects()
        
        doc = await subjects_col.find_one({
            "_id": subject_id,
            "user_id": user_id
        })
        
        return Subject(**doc) if doc else None

    @staticmethod
    async def get_subject_by_name(
        *,
        user_id: ObjectId,
        subject_name: str,
    ) -> Optional[Subject]:
        """
        Retrieve subject by name (ownership enforced).
        """
        subjects_col = db.subjects()
        
        doc = await subjects_col.find_one({
            "user_id": user_id,
            "subject_name": subject_name
        })
        
        return Subject(**doc) if doc else None

    # ============================
    # LIST SUBJECTS
    # ============================

    @staticmethod
    async def list_user_subjects(
        *,
        user_id: ObjectId,
        status: Optional[str] = None,
    ) -> List[Subject]:
        """
        List all subjects for a user.
        
        Args:
            user_id: User ID
            status: Filter by status (created, syllabus_uploaded, planned, in_progress, completed)
        """
        subjects_col = db.subjects()
        
        query = {"user_id": user_id}
        if status:
            query["status"] = status
        
        cursor = subjects_col.find(query).sort("created_at", -1)
        docs = await cursor.to_list(None)
        
        return [Subject(**doc) for doc in docs]

    # ============================
    # VALIDATION HELPERS
    # ============================

    @staticmethod
    async def validate_has_syllabus(
        *,
        user_id: ObjectId,
        subject_id: ObjectId,
    ) -> Subject:
        """
        Ensure subject has syllabus uploaded.
        
        Used by:
        - PlannerService (before generating plan)
        - StudySessionService (before creating session)
        
        Raises:
            ValueError: If syllabus not uploaded
        """
        subject = await SubjectService.get_subject_by_id(
            user_id=user_id,
            subject_id=subject_id
        )
        
        if not subject:
            raise ValueError("Subject not found")
        
        if not subject.syllabus_id:
            raise ValueError(
                "❌ Syllabus not uploaded. "
                "Upload syllabus before proceeding."
            )
        
        return subject

    @staticmethod
    async def validate_has_plan(
        *,
        user_id: ObjectId,
        subject_id: ObjectId,
    ) -> Subject:
        """
        Ensure subject has study plan generated.
        
        Used by:
        - StudySessionService (before creating session)
        
        Raises:
            ValueError: If plan not generated
        """
        subject = await SubjectService.get_subject_by_id(
            user_id=user_id,
            subject_id=subject_id
        )
        
        if not subject:
            raise ValueError("Subject not found")
        
        if not subject.plan or len(subject.plan) == 0:
            raise ValueError(
                "❌ Study plan not generated. "
                "Click 'Generate Plan' first."
            )
        
        return subject

    # ============================
    # STATUS MANAGEMENT
    # ============================

    @staticmethod
    async def update_status(
        *,
        user_id: ObjectId,
        subject_id: ObjectId,
        status: str,
    ) -> Subject:
        """
        Manually update subject status.
        
        Valid statuses:
        - created
        - syllabus_uploaded
        - planned
        - in_progress
        - completed
        - archived
        """
        VALID_STATUSES = {
            "created", "syllabus_uploaded", "planned",
            "in_progress", "completed", "archived"
        }
        
        if status not in VALID_STATUSES:
            raise ValueError(f"Invalid status. Must be one of: {VALID_STATUSES}")
        
        subjects_col = db.subjects()
        
        result = await subjects_col.update_one(
            {
                "_id": subject_id,
                "user_id": user_id
            },
            {
                "$set": {
                    "status": status,
                    "updated_at": datetime.utcnow()
                }
            }
        )
        
        if result.matched_count == 0:
            raise ValueError("Subject not found or unauthorized")
        
        updated = await subjects_col.find_one({"_id": subject_id})
        return Subject(**updated)

    # ============================
    # DELETE (Cascading)
    # ============================

    @staticmethod
    async def delete_subject(
        *,
        user_id: ObjectId,
        subject_id: ObjectId,
    ) -> bool:
        """
        Delete subject and ALL related data.
        
        Cascading deletes:
        - Syllabus
        - PlannerState
        - StudySessions
        - Chats
        - ChatMemory
        - Notes metadata (files remain)
        
        Returns:
            True if deleted, False if not found
        """
        subjects_col = db.subjects()
        syllabus_col = db.syllabus()
        planner_col = db.planner_state()
        sessions_col = db.study_sessions()
        chats_col = db.chats()
        memory_col = db.chat_memory()
        notes_col = db.notes()
        
        # Verify ownership
        subject = await subjects_col.find_one({
            "_id": subject_id,
            "user_id": user_id
        })
        
        if not subject:
            return False
        
        # 1. Delete syllabus
        if subject.get("syllabus_id"):
            await syllabus_col.delete_one({"_id": subject["syllabus_id"]})
        
        # 2. Delete planner state
        await planner_col.delete_many({"subject_id": subject_id})
        
        # 3. Get all sessions
        sessions = await sessions_col.find({"subject_id": subject_id}).to_list(None)
        session_ids = [s["_id"] for s in sessions]
        
        # 4. Delete chats and memory
        if session_ids:
            await chats_col.delete_many({"session_id": {"$in": session_ids}})
            await memory_col.delete_many({"session_id": {"$in": session_ids}})
        
        # 5. Delete sessions
        await sessions_col.delete_many({"subject_id": subject_id})
        
        # 6. Delete notes metadata
        await notes_col.delete_many({"subject_id": subject_id})
        
        # 7. Finally, delete subject
        result = await subjects_col.delete_one({"_id": subject_id})
        
        return result.deleted_count > 0